# ডাটাবেস ইন্টারভিউ প্রশ্ন ও উত্তর (বাংলায়)

## ১. রিলেশনাল ডাটাবেস কী, এবং PostgreSQL-এর মতো সিস্টেমে ডাটা কীভাবে সংগঠিত হয়?
রিলেশনাল ডাটাবেস ডাটাকে টেবিলে সংগঠিত করে, যেখানে প্রতিটি টেবিলে রয়েছে সারি (rows) এবং কলাম (columns)। প্রতিটি টেবিল একটি এন্টিটি প্রতিনিধিত্ব করে, এবং কলামগুলো সেই এন্টিটির বৈশিষ্ট্য নির্দেশ করে। সারিগুলো পৃথক রেকর্ড প্রতিনিধিত্ব করে। PostgreSQL-এ, ডাটা নির্দিষ্ট স্কিমার সাথে টেবিলে সংরক্ষিত হয়, যা ডাটা টাইপ এবং কনস্ট্রেইন্ট (যেমন, প্রাইমারি কী, ফরেন কী) বাধ্যতামূলক করে। টেবিলগুলো কী-এর মাধ্যমে একে অপরের সাথে সম্পর্কিত, যা SQL ব্যবহার করে ডাটা পুনরুদ্ধার এবং ম্যানিপুলেশনের জন্য স্ট্রাকচার্ড কোয়েরি সক্ষম করে।

## ২. নন-রিলেশনাল (NoSQL) ডাটাবেস কী, এবং কোন ধরনের অ্যাপ্লিকেশনে MongoDB ভালো পছন্দ?
নন-রিলেশনাল (NoSQL) ডাটাবেস ডাটাকে নমনীয়, স্কিমা-বিহীন ফরম্যাটে সংরক্ষণ করে, যেমন ডকুমেন্ট, কী-ভ্যালু পেয়ার, বা গ্রাফ, যা রিলেশনাল ডাটাবেসের কঠোর টেবিল কাঠামোর বিপরীত। MongoDB, একটি ডকুমেন্ট-ভিত্তিক NoSQL ডাটাবেস, ডাটাকে JSON-এর মতো ডকুমেন্ট হিসেবে সংরক্ষণ করে। এটি নিম্নলিখিত অ্যাপ্লিকেশনের জন্য উপযুক্ত:
- **নমনীয় স্কিমা**: দ্রুত পরিবর্তনশীল ডাটা স্ট্রাকচার, যেমন কনটেন্ট ম্যানেজমেন্ট সিস্টেম।
- **উচ্চ স্কেলেবিলিটি**: বিগ ডাটা অ্যাপ্লিকেশন যেখানে হরাইজন্টাল স্কেলিং প্রয়োজন, যেমন রিয়েল-টাইম অ্যানালিটিক্স।
- **অস্ট্রাকচার্ড বা সেমি-স্ট্রাকচার্ড ডাটা**: সোশ্যাল মিডিয়া প্ল্যাটফর্ম বা IoT অ্যাপ্লিকেশন।

## ৩. PostgreSQL এবং MongoDB-এর মধ্যে ডাটা স্ট্রাকচার, সম্পর্ক এবং কনসিস্টেন্সির ক্ষেত্রে প্রধান পার্থক্যগুলো কী?
- **ডাটা স্ট্রাকচার**:
  - **PostgreSQL**: নির্দিষ্ট স্কিমা সহ টেবিল ব্যবহার করে (সারি এবং কলাম)।
  - **MongoDB**: নমনীয় স্কিমা সহ JSON-এর মতো ডকুমেন্টের কালেকশন ব্যবহার করে।
- **সম্পর্ক**:
  - **PostgreSQL**: ফরেন কী এবং জয়েন ব্যবহার করে সম্পর্ক পরিচালনা করে।
  - **MongoDB**: ডকুমেন্ট এম্বেডিং বা ID রেফারেন্সিংয়ের মাধ্যমে সম্পর্ক পরিচালনা করে, নেটিভ জয়েন ছাড়া।
- **কনসিস্টেন্সি**:
  - **PostgreSQL**: ACID-সম্মত, ট্রানজেকশনের জন্য শক্তিশালী কনসিস্টেন্সি নিশ্চিত করে।
  - **MongoDB**: ডিস্ট্রিবিউটেড সেটআপে ইভেনচুয়াল কনসিস্টেন্সি প্রদান করে, অ্যাভেলেবিলিটি এবং পার্টিশন টলারেন্সকে প্রাধান্য দেয় (CAP থিওরেম)।

## ৪. Prisma কীভাবে PostgreSQL ডাটাবেসে এক-এক, এক-থেকে-অনেক, বা অনেক-থেকে-অনেক সম্পর্ক পরিচালনা করে?
Prisma, PostgreSQL-এর জন্য একটি ORM, ডিক্লারেটিভ সিনট্যাক্স ব্যবহার করে তার স্কিমায় সম্পর্ক পরিচালনা করে:
- **এক-এক**: একটি ইউনিক ফরেন কী ব্যবহার করে সংজ্ঞায়িত। উদাহরণ: `User`-এর একটি `Profile` আছে, যেখানে `Profile`-এর `userId` এবং `User`-এর `id` এর মধ্যে `@relation` লিঙ্ক করে।
- **এক-থেকে-অনেক**: একটি টেবিলের একটি রেকর্ড অন্য টেবিলের একাধিক রেকর্ডের সাথে সম্পর্কিত। উদাহরণ: `User`-এর অনেকগুলো `Post` আছে, যেখানে `Post`-এ একটি `userId` ফরেন কী থাকে।
- **অনেক-থেকে-অনেক**: একটি জাংশন টেবিল ব্যবহার করে। উদাহরণ: `User` এবং `Group` এর মধ্যে `UserGroup` টেবিল `userId` এবং `groupId` লিঙ্ক করে। Prisma `@relation` এবং ইমপ্লিসিট জয়েন টেবিল দিয়ে এটি স্বয়ংক্রিয়ভাবে পরিচালনা করে।
Prisma টাইপ-সেফ কোয়েরি তৈরি করে, যা SQL জটিলতা সরল করে।

## ৫. Mongoose কীভাবে MongoDB কালেকশনের মধ্যে সম্পর্ক পরিচালনা করে? রেফারেন্স বা এম্বেডিং ব্যবহার করে ব্যাখ্যা করুন।
Mongoose, MongoDB-এর জন্য একটি ODM, দুটি উপায়ে সম্পর্ক পরিচালনা করে:
- **এম্বেডিং**: ডাটা একটি ডকুমেন্টের মধ্যে নেস্টেড থাকে। উদাহরণ: একটি `User` ডকুমেন্টে `Post` অবজেক্টের অ্যারে থাকে। ঘনিষ্ঠভাবে সম্পর্কিত ডাটার জন্য উপযুক্ত, যা একসাথে অ্যাক্সেস করা হয়।
  ```javascript
  const userSchema = new mongoose.Schema({
    name: String,
    posts: [{ title: String, content: String }]
  });
  ```
- **রেফারেন্সিং**: কালেকশন জুড়ে ডকুমেন্ট লিঙ্ক করতে ObjectId ব্যবহার করে। উদাহরণ: `Post` একটি `userId` দিয়ে `User` রেফারেন্স করে। Mongoose-এর `populate()` মেথড সম্পর্কিত ডাটা পুনরুদ্ধার করে।
  ```javascript
  const postSchema = new mongoose.Schema({
    title: String,
    userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' }
  });
  ```
এম্বেডিং দ্রুত কিন্তু ডকুমেন্টের আকার বাড়ায়, আর রেফারেন্সিং রিলেশনাল জয়েনের মতো কাজ করে কিন্তু অতিরিক্ত কোয়েরির প্রয়োজন হয়।

## ৬. কোন ধরনের রিয়েল-ওয়ার্ল্ড প্রজেক্টে আপনি Mongoose-এর উপর Prisma বেছে নেবেন? আপনার পছন্দের যুক্তি দিন।
Prisma নিম্নলিখিত প্রজেক্টের জন্য বেছে নেওয়া উচিত:
- **স্ট্রাকচার্ড ডাটা এবং জটিল সম্পর্ক**: যেমন, ফিনান্সিয়াল সিস্টেম যেখানে ACID কমপ্লায়েন্স এবং জয়েন অত্যন্ত গুরুত্বপূর্ণ।
- **টাইপ সেফটি**: Prisma-এর টাইপ-সেফ কোয়েরি রানটাইম ত্রুটি কমায়, যা TypeScript-ভিত্তিক ই-কমার্স প্ল্যাটফর্মের জন্য আদর্শ।
- **SQL ডাটাবেস ইন্টিগ্রেশন**: CRM সিস্টেমের মতো অ্যাপ্লিকেশনের জন্য, যেখানে শক্তিশালী ট্রানজেকশন প্রয়োজন, Prisma PostgreSQL-এর সাথে নির্বিঘ্নে কাজ করে।
Mongoose নমনীয়, ডকুমেন্ট-ভিত্তিক অ্যাপ্লিকেশন যেমন সোশ্যাল মিডিয়া প্ল্যাটফর্মের জন্য উপযুক্ত, কিন্তু স্ট্রাকচার্ড, রিলেশনাল ডাটা এবং শক্তিশালী কনসিস্টেন্সির জন্য Prisma ভালো।

## ৭. Prisma-তে স্কিমা মাইগ্রেশন কী, এবং এটি কেন একাধিক পরিবেশে (যেমন, ডেভেলপমেন্ট এবং প্রোডাকশন) কাজ করার সময় গুরুত্বপূর্ণ?
Prisma-তে স্কিমা মাইগ্রেশন হলো ডাটাবেস স্কিমাকে Prisma স্কিমা ফাইলের পরিবর্তনের (যেমন, নতুন টেবিল বা ফিল্ড যোগ করা) সাথে মিলিয়ে আপডেট করা। Prisma-এর `migrate` কমান্ড SQL মাইগ্রেশন তৈরি করে এবং প্রয়োগ করে। এটি একাধিক পরিবেশে গুরুত্বপূর্ণ কারণ:
- **কনসিস্টেন্সি**: ডেভেলপমেন্ট, স্টেজিং এবং প্রোডাকশন ডাটাবেসের স্কিমা একই থাকে।
- **ভার্সন কন্ট্রোল**: স্কিমা পরিবর্তন ট্র্যাক করে, পরিবেশের মধ্যে ড্রিফট প্রতিরোধ করে।
- **নিরাপত্তা**: ধাপে ধাপে পরিবর্তন প্রয়োগ করে ডাটা হারানোর ঝুঁকি কমায়।

## ৮. MongoDB-এর নমনীয় (স্কিমা-বিহীন) কাঠামোর সুবিধা এবং অসুবিধাগুলো কী?
- **সুবিধা**:
  - **নমনীয়তা**: পরিবর্তনশীল ডাটা প্রয়োজনীয়তার সাথে সহজে খাপ খায়, স্টার্টআপ বা প্রোটোটাইপিংয়ের জন্য আদর্শ।
  - **স্কেলেবিলিটি**: ডিস্ট্রিবিউটেড সিস্টেমে হরাইজন্টাল স্কেলিং সমর্থন করে।
  - **দ্রুত ডেভেলপমেন্ট**: পূর্বনির্ধারিত কঠোর স্কিমার প্রয়োজন নেই।
- **অসুবিধা**:
  - **ডাটা অসঙ্গতি**: স্কিমার অভাবে ডাটা ফরম্যাট অসঙ্গত হতে পারে।
  - **কোয়েরি জটিলতা**: জয়েনের অভাবে ম্যানুয়াল ডাটা অ্যাগ্রিগেশন প্রয়োজন।
  - **মেইনটেন্যান্স ওভারহেড**: বড় ডাটাসেট রিফ্যাক্টরিং কঠিন।

## ৯. অ্যাপ্লিকেশনে (Prisma/Mongoose) ডাটা ভ্যালিডেশন বনাম ডাটাবেসে ভ্যালিডেশনের সুবিধা এবং অসুবিধাগুলো কী?
- **অ্যাপ্লিকেশন-লেভেল ভ্যালিডেশন (Prisma/Mongoose)**:
  - **সুবিধা**:
    - অ্যাপ্লিকেশনের প্রয়োজন অনুযায়ী নমনীয় লজিক।
    - কোডে কেন্দ্রীভূত ভ্যালিডেশন, আপডেট করা সহজ।
    - ব্যবহারকারীর জন্য উন্নত ত্রুটি হ্যান্ডলিং।
  - **অসুবিধা**:
    - সরাসরি ডাটাবেস অ্যাক্সেস হলে ভ্যালিডেশন বাইপাস হওয়ার ঝুঁকি।
    - অ্যাপ্লিকেশন-লেভেল চেকের জন্য পারফরম্যান্স ওভারহেড।
- **ডাটাবেস-লেভেল ভ্যালিডেশন**:
  - **সুবিধা**:
    - উৎসে ডাটা ইন্টিগ্রিটি নিশ্চিত করে, অবৈধ ডাটা এন্ট্রি প্রতিরোধ করে।
    - প্রয়োজনীয় ফিল্ড বা ডাটা টাইপের মতো সাধারণ কনস্ট্রেইন্টের জন্য দ্রুত।
  - **অসুবিধা**:
    - ডাটাবেস-সমর্থিত নিয়মে সীমাবদ্ধ, জটিল লজিকের জন্য কম নমনীয়।
    - স্কিমা পরিবর্তন ছাড়া কনস্ট্রেইন্ট পরিবর্তন করা কঠিন।

## ১০. ডাটাবেসে ইনডেক্স কী, এবং এটি PostgreSQL বা MongoDB-তে কোয়েরি পারফরম্যান্স কীভাবে উন্নত করে?
ইনডেক্স হলো একটি ডাটাবেস স্ট্রাকচার যা নির্দিষ্ট কলামের জন্য লুকআপ তৈরি করে ডাটা পুনরুদ্ধারের গতি বাড়ায়। PostgreSQL-এ, ইনডেক্স (যেমন, B-tree, Hash) টেবিল স্ক্যান কমিয়ে কোয়েরির সময় কমায়। MongoDB-তে, `_id` বা ঘন ঘন কোয়েরি করা ফিল্ডে ইনডেক্স ডকুমেন্ট লুকআপ দক্ষ করে। ইনডেক্স রিড পারফরম্যান্স বাড়ায় কিন্তু ডাটা আপডেটের সময় মেইনটেন্যান্সের জন্য রাইট পারফরম্যান্স কমায়।

## ১১. MongoDB-তে তিনটি নির্দিষ্ট ইনডেক্সিং টেকনিক তালিকাভুক্ত করুন এবং প্রতিটি কখন ব্যবহার করা উচিত তা ব্যাখ্যা করুন।
- **সিঙ্গেল ফিল্ড ইনডেক্স**:
  - বর্ণনা: একটি একক ফিল্ডে ইনডেক্স তৈরি করে দক্ষ কোয়েরির জন্য।
  - ব্যবহার: নির্দিষ্ট ফিল্ডে ঘন ঘন কোয়েরির জন্য, যেমন, `db.users.createIndex({ email: 1 })` ইমেইল-ভিত্তিক লুকআপের জন্য।
- **কম্পাউন্ড ইনডেক্স**:
  - বর্ণনা: একাধিক ফিল্ডে ইনডেক্স তৈরি করে একাধিক ক্রাইটেরিয়া সহ কোয়েরি অপটিমাইজ করে।
  - ব্যবহার: একাধিক ফিল্টার সহ কোয়েরির জন্য, যেমন, `db.orders.createIndex({ customerId: 1, orderDate: -1 })` কাস্টমার এবং তারিখ অনুসারে অর্ডার সর্টিংয়ের জন্য।
- **টেক্সট ইনডেক্স**:
  - বর্ণনা: স্ট্রিং ফিল্ডে ফুল-টেক্সট সার্চ সক্ষম করে।
  - ব্যবহার: সার্চ অ্যাপ্লিকেশনের জন্য, যেমন, `db.articles.createIndex({ content: "text" })` আর্টিকেল কনটেন্ট সার্চের জন্য।

## ১২. PostgreSQL-এ ট্রানজেকশন কীভাবে কাজ করে, এবং একাধিক অপারেশনে ডাটা নির্ভুলতার জন্য এটি কেন গুরুত্বপূর্ণ?
PostgreSQL ট্রানজেকশন একাধিক অপারেশনকে একটি একক ইউনিটে গ্রুপ করে, ACID প্রোপার্টি অনুসরণ করে:
- **অ্যাটমিসিটি**: সব অপারেশন একসাথে সফল বা ব্যর্থ হয়।
- **কনসিস্টেন্সি**: ডাটাবেস বৈধ অবস্থায় থাকে।
- **আইসোলেশন**: ট্রানজেকশন একে অপরের থেকে স্বাধীন, আংশিক আপডেট প্রতিরোধ করে।
- **ডিউরাবিলিটি**: কমিটেড পরিবর্তন স্থায়ীভাবে সংরক্ষিত হয়।
উদাহরণ: `BEGIN; UPDATE accounts SET balance = balance - 100 WHERE id = 1; UPDATE accounts SET balance = balance + 100 WHERE id = 2; COMMIT;`। ট্রানজেকশন মানি ট্রান্সফারের মতো মাল্টি-স্টেপ অপারেশনে নির্ভুলতা নিশ্চিত করে, ত্রুটির ক্ষেত্রে আংশিক আপডেট প্রতিরোধ করে।

## ১৩. MongoDB-এর ট্রানজেকশন সিস্টেমের সীমাবদ্ধতা কী, এবং এর ইভেনচুয়াল কনসিস্টেন্সি রিয়েল-ওয়ার্ল্ড অ্যাপ্লিকেশনে কীভাবে সমস্যা সৃষ্টি করতে পারে?
- **সীমাবদ্ধতা**:
  - ট্রানজেকশন শুধুমাত্র রেপ্লিকা সেট বা শার্ডেড ক্লাস্টারে সমর্থিত (MongoDB 4.0+)।
  - ডিফল্টভাবে ৬০ সেকেন্ডে সীমাবদ্ধ, জটিল অপারেশনে টাইমআউটের ঝুঁকি।
  - নন-ট্রানজেকশনাল রাইটের তুলনায় পারফরম্যান্স ওভারহেড বেশি।
- **ইভেনচুয়াল কনসিস্টেন্সি সমস্যা**:
  - ডিস্ট্রিবিউটেড সেটআপে, রেপ্লিকেশন সম্পূর্ণ হওয়ার আগে রিড পুরোনো ডাটা ফেরত দিতে পারে।
  - উদাহরণ: একটি ব্যাঙ্কিং অ্যাপে, ট্রান্সফারের পর ব্যবহারকারী পুরোনো ব্যালেন্স দেখতে পারে, যা পরবর্তী ট্রানজেকশনে বিভ্রান্তি বা ত্রুটি সৃষ্টি করতে পারে।
  - সমাধান: শক্তিশালী কনসিস্টেন্সির জন্য `writeConcern: { w: "majority" }` এবং `readConcern: "snapshot"` ব্যবহার করুন, যদিও এটি পারফরম্যান্স কমায়।

## ১৪. PostgreSQL এবং MongoDB উভয় ব্যবহার করে একটি সিস্টেম কীভাবে ডিজাইন করবেন? কোন ধরনের ডাটা কোন ডাটাবেসে যাবে এবং কেন?
- **সিস্টেম ডিজাইন**:
  - PostgreSQL ব্যবহার করুন স্ট্রাকচার্ড, রিলেশনাল ডাটার জন্য যেখানে শক্তিশালী কনসিস্টেন্সি প্রয়োজন (যেমন, ইউজার অ্যাকাউন্ট, ফিনান্সিয়াল ট্রানজেকশন)।
  - MongoDB ব্যবহার করুন অস্ট্রাকচার্ড বা সেমি-স্ট্রাকচার্ড ডাটার জন্য যেখানে উচ্চ রাইট থ্রুপুট প্রয়োজন (যেমন, লগ, ইউজার-জেনারেটেড কনটেন্ট)।
  - অ্যাপ্লিকেশন লেয়ার (যেমন, Node.js) দিয়ে দুটি ডাটাবেস কোয়েরি করুন, ডাটা সিঙ্ক্রোনাইজ বা অ্যাগ্রিগেট করতে API ব্যবহার করুন।
- **ডাটা বণ্টন**:
  - **PostgreSQL**: ইউজার প্রোফাইল, অর্ডার হিস্ট্রি, পেমেন্ট রেকর্ড (ACID কমপ্লায়েন্স এবং জয়েন প্রয়োজন)।
  - **MongoDB**: প্রোডাক্ট রিভিউ, ইভেন্ট লগ, রিয়েল-টাইম অ্যানালিটিক্স (স্কিমা নমনীয়তা এবং স্কেলেবিলিটির সুবিধা)।
- **কেন**: PostgreSQL গুরুত্বপূর্ণ অপারেশনের জন্য ডাটা ইন্টিগ্রিটি নিশ্চিত করে; MongoDB উচ্চ-ভলিউম, নমনীয় ডাটা দক্ষতার সাথে পরিচালনা করে।

## ১৫. MongoDB থেকে PostgreSQL-এ প্রজেক্ট মাইগ্রেট করার সময় মূল চ্যালেঞ্জগুলো কী? স্ট্রাকচার, ডাটা কনভার্সন এবং কনসিস্টেন্সির উপর ফোকাস করুন।
- **স্ট্রাকচার**:
  - চ্যালেঞ্জ: MongoDB-এর স্কিমা-বিহীন ডকুমেন্টকে PostgreSQL-এর কঠোর টেবিলে ম্যাপ করা।
  - সমাধান: টেবিল স্কিমা সংজ্ঞায়িত করুন, এম্বেডেড ডাটাকে ফরেন কী সহ সম্পর্কিত টেবিলে নরমালাইজ করুন।
- **ডাটা কনভার্সন**:
  - চ্যালেঞ্জ: JSON-এর মতো ডকুমেন্টকে রিলেশনাল সারিতে রূপান্তর, নেস্টেড অ্যারে বা অবজেক্ট হ্যান্ডল করা।
  - সমাধান: নেস্টেড ডাটা ফ্ল্যাট করতে স্ক্রিপ্ট লিখুন, ফিল্ডকে কলামে ম্যাপ করুন, এবং মিসিং বা অসঙ্গত ডাটা হ্যান্ডল করুন।
- **কনসিস্টেন্সি**:
  - চ্যালেঞ্জ: MongoDB-এর ইভেনচুয়াল কনসিস্টেন্সি মাইগ্রেশনের সময় ডাটাকে অসঙ্গত অবস্থায় ফেলতে পারে।
  - সমাধান: ডাটা কনসিস্টেন্সি নিশ্চিত করতে MongoDB ট্রানজেকশন বা স্ন্যাপশট রিড ব্যবহার করুন, মাইগ্রেটেড ডাটা ভ্যালিডেট করুন, এবং PostgreSQL-এ ইন্টিগ্রিটি কনস্ট্রেইন্ট পরীক্ষা করুন।